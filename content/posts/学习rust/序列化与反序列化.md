+++
title = "Rust 序列化与反序列化"
date = "2025-04-26T00:00:00+08:00"
categories = ["学习Rust"]
tags = ["Rust", "Rust序列化与反序列"]
+++

## bincode

For example:

```rust
// Cargo.toml 依赖：
// [dependencies]
// serde = { version = "1.0", features = ["derive"] }
// bincode = "1.3"

use serde::{Deserialize, Serialize};
use std::error::Error;

// 1. 定义数据结构并派生必要的 trait
#[derive(Debug, Serialize, Deserialize, PartialEq)]
struct Person {
    name: String,
    age: u8,
    hobbies: Vec<String>,
    is_active: bool,
}

fn main() -> Result<(), Box<dyn Error>> {
    // 2. 创建原始数据
    let original_person = Person {
        name: "Alice".to_string(),
        age: 30,
        hobbies: vec!["Reading".to_string(), "Hiking".to_string(), "Coding".to_string()],
        is_active: true,
    };

    println!("=== 原始数据 ===");
    println!("{:#?}", original_person);
    println!();

    // 3. 序列化 (Rust结构体 -> 二进制)
    println!("=== 序列化过程 ===");
    let binary_data: Vec<u8> = bincode::serialize(&original_person)?;
    println!("序列化成功！二进制数据长度: {} 字节", binary_data.len());
    println!("二进制数据 (十六进制): {:02X?}", binary_data);
    println!("二进制数据 (原始): {:?}", binary_data);
    println!();

    // 4. 反序列化 (二进制 -> Rust结构体)
    println!("=== 反序列化过程 ===");
    let deserialized_person: Person = bincode::deserialize(&binary_data)?;
    println!("反序列化成功！");
    println!("{:#?}", deserialized_person);
    println!();

    // 5. 验证数据完整性
    println!("=== 数据验证 ===");
    if original_person == deserialized_person {
        println!("✅ 序列化-反序列化循环验证成功！数据完整无损。");
    } else {
        println!("❌ 数据不一致！");
    }

    // 6. 演示错误处理（可选）
    println!();
    println!("=== 错误处理演示 ===");
    let invalid_data = vec![0, 1, 2, 3, 4]; // 无效的二进制数据
    match bincode::deserialize::<Person>(&invalid_data) {
        Ok(_) => println!("意外的成功"),
        Err(e) => println!("预期的反序列化错误: {}", e),
    }

    Ok(())
}
```

输出:

```
=== 原始数据 ===
Person {
    name: "Alice",
    age: 30,
    hobbies: [
        "Reading",
        "Hiking",
        "Coding",
    ],
    is_active: true,
}

=== 序列化过程 ===
序列化成功！二进制数据长度: 40 字节
二进制数据 (十六进制): [05, 00, 00, 00, 00, 00, 00, 00, 41, 6C, 69, 63, 65, 1E, 03, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, 52, 65, 61, 64, 69, 6E, 67, 06, 00, 00, 00, 00, 00, 00, 00, 48, 69, 6B, 69, 6E, 67, 06, 00, 00, 00, 00, 00, 00, 00, 43, 6F, 64, 69, 6E, 67, 01]

=== 反序列化过程 ===
反序列化成功！
Person {
    name: "Alice",
    age: 30,
    hobbies: [
        "Reading",
        "Hiking",
        "Coding",
    ],
    is_active: true,
}

=== 数据验证 ===
✅ 序列化-反序列化循环验证成功！数据完整无损。

=== 错误处理演示 ===
预期的反序列化错误: io error: failed to fill whole buffer
```

bincode 使用一种简单的二进制格式，主要基于：
1.  **小端序**（Little-endian）字节顺序
2.  **长度前缀** 表示可变长度数据（如字符串、数组）
3.  **直接值表示** 对于基本类型

```
// 长度前缀: 8字节 (u64) 小端序
[05, 00, 00, 00, 00, 00, 00, 00] → 0x0000000000000005 = 5 (字符串长度)

// UTF-8 字符串内容
[41, 6C, 69, 63, 65] → 'A' 'l' 'i' 'c' 'e' = "Alice"
```

```
[1E] → 0x1E = 30 (直接值)
```
